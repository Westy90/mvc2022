{% extends "base.html.twig" %}


{% block title %}Report{% endblock %}

{% block content %}

<h1> Report </h1>
Här presenteras redovisningstexter för kursens kmom.


<h1> KMOM01 </h1>

<p>Jag har tidigare läst en introduktionskurs i c++ 10,5 hp där objektorienterad programmering ingick
    jag har även läst kursen oopython vid tidigare kursperiod. Förra året läste jag oophp men kom
    bara till kmom02, så jag misslyckades med kursen. Men det är nya tag som gäller nu!
    <br><br>
    Gällande objektorienterat i php så är en klass en slags "mall" som sedan objekt instansieras från.
    En instans/objekt innehåller properties (som är som variabler som tillhör instansen).
    <br><br>
    Metoder, som är definerade i klassen överförs inte till själva instansen utan lagras i
    klassen och anropas genom den. Däremot om man skapar metoder till den specifika instansen, så lagras det i den specifika instansen.
    Detta uppfattar jag som en skillnad mot python där hela klassens properties och metoder kopierades till
    instansen.
    <br><br>
    Man bör inte ändra/läsa en instans properties direkt utan det bör gå genom getter och setters-metoder
    som kan på ett kontrollerat sätt ändra instansens properties, vilket blir som ett slags API.
    Genom inkapsling, dvs att sätta en properties som private, så kan man på ett "hårt" sätt hindra att
    properties ändras utan getters/setters. Det är en viss skillnad mot python där man satte ett underscore
    framför propertien för att indikera att den var private, men på ett "mjukt" sätt, dvs det gick
    ändå att ändra den utan en setter-metod.
    <br><br>
    Jag tycker att strukturen är mycket bättre än förra årets struktur. Dels bra att det är styrt
    att vi kör på ett ramverk. Det är också tydligare hur routern fungerar och jag känner att jag kan
    dra paraleller till hur vi arbetade med databaskursen och htmlphp, vilket jag hade svårare att förstå
    förra året. Jag gillar nog särskilt strukturen för base.html.twig och hur de olika blocken
    ersätts av home/report/about, det är en tydlig paralell till hur vi gjorde i htmlphp.
    <br><br>
    De delar inom PHP the right way som jag ögnade igenom och kändes intressanta var databaser, om vi
    kan jobba på ett än smidigare sätt än vad vi gjorde i databaskursen/htmlphp. Servers and deployment,
    vore intressant att veta hur man skulle kunna sätta upp en server lite mer självständigt, alltså
    att inte använda studentservern utan att använda exempelvis en raspberry pie eller något, dock kanske 
    utanför kursen scope. Sedan så tycker jag segementet om säkerhet vore intressant att djupdyka i,
    hur man ska hantera inkommande data och hur man ska kryptera. Det var ju något vi vidrörde i
    htmlphp samt också till viss del i python-kursen vilket jag tyckte ver intressant.
    <br><br>
    Mitt TIL för detta kursmoment var väl helheten, att det gick ganska lätt att greppa
    konceptet med routing och controllers.
</p>

<h1> KMOM02 </h1>

<p> Något jag uppskattar är när kurserna hänger ihop på ett eller annat sätt. Exempelvis i oopython
    går vi igenom websequencediagram och i läshanvisningar i detta kursmoment används sådana i läsmaterialet på
    https://symfony.com/doc/current/introduction/http_fundamentals.html . Nu användes den ju in ett väldigt enkelt och 
    lättsamt exempel. Men ändå bra. Det är en liten detalj men ändå nice tycker jag!
    <br><br>
    Arv innebär att en klass ärver från en annan klass, det blir en specialisering. I min kod så ser jag att jag kanske borde
    använt Hand som en klass och sedan kunde Deck varit en specialisering då de delar mycket av sin funktionalitet. I en child
    i ett arvförhållande kan man lägga till ny funktionalitet eller göra element mer "öppna", ex ändra private till public.
    Man kan dock inte göra det omvända, att göra element till private som tidigare var public. Detta är eftersom ett barn
    att ersätta en förälder i klassen och om man gjort det mer private så hade det inte gått att nå dessa för andra metoder 
    som tidigare nådde dom i public för föräldern.

    <br><br>
    För deck och hand så använder jag arv. För jag ser det som att både har en funktion att hålla kort 
    men att deck är en specialisering av hand med mer funktionalitet och metoder. Därav ärver deck-klassen från hand-klassen. 
    Jag kunde också ha löst detta genom ett trait som haft de gemensamma koddelarna och sedan "kopierats in" i vardera klass
    <br><br>

    Association innebär att det finns en relation mellan två klasser. I min kod finns exempel där player har en hand och hand 
    innehåller ett antal kort. Dessa två är två olika typer av relation. Den första, är composition, om player försvinner så kommer även
    handen att försvinna, handen kan inte "leva" utan player. Den andra, mellan hand och card är det Aggregation, där korten är skapade 
    utanför handen och sedan inlagda, de lever alltså utanför handen, och om handen skulle försvinna så finns korten kvar.

    <br><br>
    Interface innebär att ett antal metoder ska finnas i en klass. Det blir kanske som ett slags "omvänt API"? Att man kan specificera att 
    ett interface ska vara ett visst antal metoder och om en klass har implementerat detta så vet man att ett antal metoder ska finnas, exempelvis
    som en getmetod?

    <br><br>
    Jag tycker instruktionerna för uppgiften var lite väl sparsamma. Däremot så är videoföreläsningarna till dessa 
    väldigt bra. Jag tycker generellt att det verkar som ett bra format med korta videoklipp än långa föreläsningar.

    <br><br>
    Mitt TIL är väl att jag har blivit någorlunda van att använda git, det har jag haft stora problem med i 
    tidigare kurser av någon anledning. Men jag tycker videoserien Mikael gjorde för kmom01 i sin egen kanal (den på engelska)
    var väldigt bra och lätt att följa! Härligt!

</p>

<h1> KMOM03 </h1>

<p> Jag tror en styrka med flödesdiagram är att om man jobbar tillsammans med många
    så kan man visuellt göra en plan för hur programmet ska var utformat. På så sätt
kan man dela ut uppgifter men samtidigt ha en förståelde för helheten. Det är säkert också
ett bra verktyg för att kommunicera med andra personer inom företaget som inte kan kod
och på så vis kan diskutera om flödesdiagram uppnår kravbilder och dylikt. Psuedokod
har jag däremot mindre förståelse för. Det känns verkligen som man skriver koden två gånger.
Jag tänker mig att ett bättre verktyg vore att skriva alla klasser och beskriva vilka input
och output de ska hantera, ex vilka getters och setters som ska finnas samt vad metoderna
ska göra i huvudsak. Det tror jag hade varit ett bra komplement till flödesdiagram i sin funktion
att kommunicera med andra teammedlemmar och andra personer inom företaget. Men jag känner att
flödesdiagram kanske gör mest nytta i mer komplexa program där många delar hänger samman.
<br><br>
Jag är väl rätt nöjd med programmet och min kod i sin helhet. Mitt stora problem var att jag
hade missuppfattat att vyerna inte fick prata direkt med objekten. Det gjorde var att controllern
skötte all kommunikation med objekten och sedan sparade ned i arrayer och skickade in i vyerna.
Det gjorde att det blev väldigt komplexa arrayer som var svåra att loopa igenom i vyerna och
jag körde fast rejält på grund av det. Men efter en hel del jämmrande på disccord-chatten så fick
jag hjälp och rättelse att vyerna kan kommunicera med objekten. Det tog bort komplexiteten rejält
och det blev mycket lättare att lösa uppgiften. I slutänden är jag som sagt rätt nöjd med hur jag byggt
upp min kod och hur klasserna fungerar mellan varandra. Jag anser också att jag arbetat enligt
"slim controllers and fat modells". Jag kan dock tänka mig att jag kunde ha gjort mer DRY-kod,
men man kan ju inte göra allt perfekt då det ändå är ett antal timmar som jag har möjlighet att
lägga på plugget, och i detta kursmoment la jag ned många "extratimmar" på grund av att jag
missuppfattade, som jag sa inledningsvis. Det är klurigt det där, att man gör ett fel som sedan
likt ringar på vattnet blir ganska omfatttande, tidsödande och frustrerande.
<br><br>
Än så länge så tycker jag det fungerar bra att koda i symfony. Lite "fel" känns det koden skiljer
sig i vyerna i jämförelse med php-kod. Exempelvis att komma åt metoderna i ett objekt görs ju
i php med hjälp av ->, men i vyerna så används en punkt. Så det känns lite förvirrande
ibland! Annars så tycker jag att flödet mellan controllers, models och vyerna känns "logiska"
och lätta att förstå.
<br><br>
Mitt TIL för detta kursmoment blir det jag beskrev innan, att vyerna kan kommunicera med
objekt direkt. Det uppfattar jag inte var tydligt i guiderna och föreläsningarna.
</p>

<h1> KMOM04 </h1>

<p>
    Så därja, då var det KMOM04... Jag uppfattar det som ganska lätt
    att skapa tester för min kod. Alla klasser förutom game var väl
    mer eller mindre enkelt. Sedan kan ju dock diskutera hur kvalitatitva
    dessa tester var. Jag använde mig mycket av assertEquals och
    assertInstancesOf. När jag läste oopythonkursen så tycker jag
    att vi gjorde med avancerad testning, ex mockade och använde flera
    typer av assertions. I denna kurs upplevde jag inte att tanken
    var att man skulle göra det så det blev på en ganska enkel nivå
    i jämförelse med oopythonkursen. I mina metoder så returnerar de antingen
    ett värde eller gör en enda operation. Det göra tt det blir enkelt att
    göra en assertion. Därför kunde jag nå upp till 100% kodtäckning på allt
    förutom game. Detta beror väl dels för jag kände att jag ville nöja mig
    och inte maxxa på allt, samt att jag kände att jag inte helt nöjd med hur
    mina metoder var skriva för game, men jag kände inte motivation att skriva om
    dom och gör dom mer testbara.
    <br><br>
    För metoden addDeck i game så ändrade jag den för att göra den mer testbar.
    Detta genom att tillåta att en annan mindre kortlek kunde användas i testet.
    I spelet används ju en stor kortlek men för testning kändes det rimligare
    att använda en liten kortlek, därav så ändrade jag så den accepterade
    en mindre kortlek. Den gjordes också så att jag kunde fylla på den lilla kortleken
    med fler kort eftersom det fanns behov av det i ett av testen för computerPlay().
    <br><br>
    Jag finner därmed att alla mina klasser är ganska bra skrivna för att testas
    undantag för game-klassen. Och nog håller jag med om att några av metoderna i game 
    inte är så "vackra", exempelvis evalutate(), och samtidigt valde jag att inte testa den.
    Så det kanske kan ses som ett bevis att snygg och ren kod också är testbar.
    <br><br>

    Som vanligt så hamnade jag i lite problem även i detta kursmoment. Det gällde väl 
    främst hur composer och script för phpunit inte riktigt fungerade. Jag bad om hjälp, 
    jag fick även hjälp, men det löste inte problemet. Vilket som vanligt känns
    frustrerande. Men men... Man får väl kämpa sig fram. Jag har även lite problem 
    att förstå vilket arbetsflöde som det är tänkt att man ska ha med git.
    Vet inte riktgt i vilken ordning jag ska göra git commit och git tags exempelvis.
    Jag försökte vara noga att göra flera commits denna gång,
    men det blev ändå svårt att göra tillräckligt många, för det var ju inte så 
    mycket kod som skulle skrivas i detta kursmoment.

</p>

<h1> KMOM05 </h1>

<p>
    Jag tycker det gick relativt smidigt att installera doctrine. Jag hade som vanligt något "småfel" som tog
    mer tid än vad jag hade önskat, men kommer inte ihåg vad det var. Jag tyckte själva övningen hade ett mycket
    bra upplägg och det blev en lagom nivå till att göra själv och utgå från övningen. Något som jag tycker
    var lite otydligt i övningen var om övningens metoder i controllern var tillräckligt "slim"? För nu gjorde
    jag på liknande sätt som övningen även i uppgiften och jag övervägde att göra en klass som var typ "database-handler",
    men jag kom inte så långt. Jag kände mig ändå nöjd med uppläggt som jag har nu, då det inte är
    särskilt mycket kod i controllern.
</p>

<p> Jag tycker uppgiften gick bra. En av "utmaningarna" jag roade mig med att bara ha en grundsida för create/update
    men att med hjälp av template ändra innehållet i de. Sedan även en grundsida för "show", oavsett om det var en eller två
    Jag blev nöjd med resultatet förutom att det blev lite osmidigt vid create då jag använde en "dummy"-instans av train
    för annars fick jag inte min lösning att fungera. För i  templatevyn så läser den in value som "value=trains[0].getAmountMade"
    och om jag inte skickat in en instans av train så blev det error. Därav så fick jag göra en dummy som inte innehöll något.
    Kanske hade man kunnat hitta en smidigare lösning? I övrigt så gick CRUD-momenten bra, men jag känner i nuläget väldigt 
    liten fördel jämfört mot att mer klassiskt skriva SQL-satser, jag är särskilt nyfiken hur bra det funkar med mer komplext 
    då man joinar tabeller och dylikt? Samtidigt förstår jag "gränssnitttänket", dvs att vissa programmerar med front end och vissa
    mer backend mot databasen. Då kan det vara smidigt om det är ett enkelt sätt att kunna hantera databasen för de som jobbar 
    front end. Särskilt om man skulle göra korrigerngar och byta DBMS och dylikt. Det känns också igenom med tänket 
    kring API-er, att göra ett gränssnitt mellan delar av programmet.
</p>
<p>
    Men i övrigt gällande CRUD i detta kursmoment såg jag inga direkta konstigheter. Och mitt TIL blir väl iprincip att 
    det var intressant att kunna se databaser från ett "annat perspektiv", än att skriva SQL-satser.
</p>

<h1> KMOM06 </h1>

<p> Det jag tycker var nyttigast i phpmetrics var att kunna se kodkomplexiteten och se vilka
    områden som är problematiska. Det visas ju också tydligt på den genererade sidan med 
    bubblorna. Som jag är på i rapporten så anser jag dock att siffrona måste sättas i sitt
    sammanhang vad det programmet ska göra, och inte bara titta på komplexiteten. Ett avancerat 
    program med komplexiteten 10 kan vara "bättre skriven" än ett enkelt program med komplexiteten 5.
    Men det är ändå bra att kunna mäta komplexiteten och göra förändringar för att det efter se
    om det har resulterar i en förbättring. Det jag också uppskattade med phpmetrics var att
    den hade avgränsat till bara min kod och inte ramverkets kod, för det uppfattade jag
    som en stor nackdel med scrutinizer att den tog allt, inklusive delar som jag nu inte
    har förståelse kring eller kan påverka, det vill säga delarna kopplat till ramverket.
</p>

<p>
    Vid min första uppladdning så fick jag 6.15 i overall score, 16% i testscore, build passed.
    När jag gjorde mina förändringar så blev overall score det samma, men testscore ökade till 19%.
    Som jag är inne på i stycket om phpmetrics så beror nog det oförändrade overall score på att
    min kod är en väldigt liten del av hela programmet vilket gör att förändringar inte påverkar så mycket.
    Samtidigt är det ju så att jag försökte minska komplexiteten utan att lyckas vilket också då
    såklart inte ger någon påverkan på min score.
</p>

<p> Vad gäller kodkvalitet så är det som sagt, att det måste sättas i sitt sammanhang för att kunna dra slutsatser.
    Och kanske är det väl "mot sig själv" man bör jämföra och förbättra. Att ett annat program har bättre score
    betyder inte nödvändigtvis att det är ett bätte program. Ett bugfritt program med tydlig kod samt löser
    sitt syfte är väl det man vill uppnå egentligen. Inte ett särskilt komplexitetstal. Sedan är det ju också
    en resurs och kostnadsfråga. Att försöka göra ett litet projekt "perfekt" när en kund har satt ett visst
    belopp/tidsgräns som då gör att man misslyckas leverera i tid för att man lägger ned för mycket tid på att 
    göra perfekt kod enligt testerna är ju inte heller bra! På så sätt är det ju lite fånigt att ha badges på en sida
    när det egentligen inte är det som är det viktiga.
</p>

<h1> KMOM10 </h1>

<p> </p>

{% endblock %}